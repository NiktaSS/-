### 1. Клиент-сервер. Разделение ответственности между клиентом и сервером

Клиент и сервер отвечают за разные вещи. Ответственность клиента — пользовательский интерфейс, ответственность сервера — данные. Если API возвращает HTML-страницу, его нельзя назвать REST API: ведь при этом сервер берёт на себя ответственность за интерфейс.

### 2. Отсутствие состояния. Сервер не хранит состояние

Каждый запрос должен быть независимым, как будто он сделан в первый раз. Сервер не должен хранить какую-либо информацию о клиенте. Каждый запрос клиента к серверу должен содержать всю информацию, необходимую для обработки этого запроса: кто запрашивает данные, какие данные запрашиваются.

### 3. Единый интерфейс

Интерфейс обращения к серверу одинаков для всех и не зависит от клиента. Запрос к данным может быть сформирован из браузера, мобильного приложения или с «умного» чайника по одним и тем же правилам.

### 4. Многоуровневость

Первый принцип гласит, что в коммуникации участвуют двое: клиент и сервер. Но можно строить более сложные системы, не нарушая этого принципа.

API сервиса Яндекс Такси может использовать API Яндекс Карт. Клиент (приложение Яндекс Такси в телефоне) взаимодействует только с API сервиса Яндекс Такси, а этот сервис, в свою очередь, выполняет роль клиента для сервиса Яндекс Карты. При таком взаимодействии есть одно условие — каждый компонент должен видеть только свой уровень данных. Например, сервис Яндекс Карты не должен видеть все данные, которые приложение на телефоне отправило в Яндекс Такси.

### 5. Кешируемость

Данные ответа могут быть закешированы. Это значит, что полученные данные можно сохранить на клиенте, а при идентичном запросе взять их из памяти клиента — кеша, а не ждать их с сервера. Нет смысла запрашивать данные повторно, если они никак не изменились.

### 6. Код по запросу

Этот принцип необязательный. Он гласит, что функциональность клиента может быть расширена кодом, приходящим с сервера. Сейчас такое можно встретить повсеместно: JavaScript используется для «оживления» страниц и исполнения каких-то сценариев на стороне клиента. Но принципы формулировались в 2000 году — тогда исполняемый код с сервера возвращали не так часто. Потому и выделили это в отдельный принцип.

